function [testvectors, testdefs] = gen_tables(switches);
    % generates input tables for testbench.m
    
    % pull out switches
    if nargin == 1
        TESTVECS_SOLO      = switches.TESTVECS_SOLO;
        TESTVECS_MIX       = switches.TESTVECS_MIX;
        TESTDEFS_MAIN      = switches.TESTDEFS_MAIN;
        TESTDEFS_NORMLEN   = switches.TESTDEFS_NORMLEN;
        TESTDEFS_SPECTINFO = switches.TESTDEFS_SPECTINFO;
        TESTDEFS_AGRESSION = switches.TESTDEFS_AGRESSION;
    else 
        % when in doubt do everything
        TESTVECS_SOLO = true;
        TESTVECS_MIX = true;
        TESTDEFS_MAIN = true;
        TESTDEFS_NORMLEN = true;
        TESTDEFS_SPECTINFO = true;
        TESTDEFS_AGRESSION = true;
    end

    % make empty testvectors/testdefs
    % a testdef is the algorithm/parameters used to solve the problem in a particular way
        % eg taxicab spectral difference with block normalisation, width 100
    % a testvec is a particular case of the problem
        % in this case that's an audio file, plus a ground-truth midi file
    testvectors = cell(0);
    testdefs = cell(0);

    % pick up some useful path strings
    PROJECT_PATH = fullfile('../../');
    TRIOS_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/TRIOS');
    PHENICX_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/PHENICX');
    DEV_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/development');

    % BUILD TEST VECTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if TESTVECS_SOLO
        % nice easy solo piano with lots of clear onsets
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartPiano", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/piano.wav"), ...
            "midiPath"  , fullfile(TRIOS_DATA_PATH, "mozart/piano.mid") ...
        );
        % viola with long notes - hard to avoid false positives
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartViola", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/viola.wav"), ...
            "midiPath"  , fullfile(TRIOS_DATA_PATH, "mozart/viola.mid") ...
        );
        % something low - cello
        testvectors{end+1} = struct( ...
            "name"       , "triosSchubertCello", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "schubert/cello.wav"), ...
            "midiPath"  , fullfile(TRIOS_DATA_PATH, "schubert/cello.mid") ...
        );
        % something high - flute
        testvectors{end+1} = struct( ...
            "name"       , "phenicxBrucknerFlute", ...
            "audioPath" , fullfile(PHENICX_DATA_PATH, "audio/bruckner/flute.wav"), ...
            "midiPath"  , fullfile(PHENICX_DATA_PATH, "annotations/bruckner/flute.mid") ... 
        );
    end

    if TESTVECS_MIX
        % mix - TRIOS brahms
        midi_stack( ...
            "./tmp/triosBrahmsMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "brahms/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "brahms/horn.mid"), ...
            fullfile(TRIOS_DATA_PATH, "brahms/violin.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosBrahmsMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "brahms/mix.wav"), ...
            "midiPath"  , "./tmp/triosBrahmsMix.mid" ...
        );
        
        % mix - TRIOS mozart
        midi_stack( ...
            "./tmp/triosMozartMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "mozart/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "mozart/clarinet.mid"), ...
            fullfile(TRIOS_DATA_PATH, "mozart/viola.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/mix.wav"), ...
            "midiPath"  , "./tmp/triosMozartMix.mid" ... 
        );

        % mix - TRIOS lussier
        midi_stack( ...
            "./tmp/triosLussierMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "lussier/bassoon.mid"), ...
            fullfile(TRIOS_DATA_PATH, "lussier/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "lussier/trumpet.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosLussierMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "lussier/mix.wav"), ...
            "midiPath"  , "./tmp/triosLussierMix.mid" ... 
        );

        % mix - TRIOS schubert
        midi_stack( ...
            "./tmp/triosSchubertMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "schubert/cello.mid"), ...
            fullfile(TRIOS_DATA_PATH, "schubert/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "schubert/violin.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosSchubertMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "schubert/mix.wav"), ...
            "midiPath"  , "./tmp/triosSchubertMix.mid" ... 
        );

        % mix - TRIOS take five
        midi_stack( ...
            "./tmp/triosTakeFiveMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "take_five/kick.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/ride.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/saxophone.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/snare.mid") ... 
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosTakeFiveMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "take_five/mix.wav"), ...
            "midiPath"  , "./tmp/triosTakeFiveMix.mid" ... 
        );

        % !!! NB not using PHENICX at the moment as no "mix.wav" is provided. not too
        % hard to hack together midi files but audio is a different matter
        % (gain settings, etc).
        % maybe will come back to it.
    end
    
    % BUILD TESTDEFS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#

    % standard spectInfo
    si_std = struct( ... 
        "wlen"    , 1024, ... 
        "nfft"    , 1024 * 4, ...
        "hop"     , 1024 / 4 ...
    );
    si_std.analwin = blackmanharris(si_std.wlen, 'periodic'); 
    si_std.synthwin = hamming(si_std.wlen, 'periodic');

    if TESTDEFS_MAIN
        % standard taxicab
        testdefs{end+1} = struct (...
            "name"     , "MStandardTaxi", ...
            "testFunc" , @aln_onsUtil_specDiff_taxi, ...
            "spectInfo", si_std ...
        );

        % standard rectL2
        testdefs{end+1} = struct (...
            "name"     , "MStandardRectL2", ...
            "testFunc" , @aln_onsUtil_specDiff_rectL2, ...
            "spectInfo", si_std ...
        );

        % taxi with pesky zero
        testdefs{end+1} = struct (...
            "name"     , "MtaxiPesky0", ...
            "testFunc" , @aln_onsUtil_specDiff_taxi_pesky0, ...
            "spectInfo", si_std ...
        );

        % taxi, with block normalisation, width 100, no dropout thresh
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,-99);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiNormNoDroput", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % taxi, with block normalisation, width 100, dropout thresh at 0dB (ie drops out below mean)
        % this is an "agressive" onset detecting strategy
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiNormLowDropout", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % taxi, with block normalisation, width 100, dropout thresh at +10dB 
        % this is a "conservative" onset detecting strategy
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,7);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiNormHighDropout", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % agressive taxi (see above) with leading-edge detection, tol 1
        f = @(s,si)aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,0),1);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiAgressLeadingEdge1", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % conservative taxi (see above) with leading-edge detection, tol 1
        f = @(s,si)aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,7),1);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiConservLeadingEdge1", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % MTaxiAgressLeadingEdge1 but with a smoothing kernel applied. mostly for plotting :)
        f = @(s,si)aln_onsUtil_smooth(aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,0),1));
        testdefs{end+1} = struct (...
            "name"     , "MTaxiAgressLeadingEdge1Smooth", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );
    end

    if TESTDEFS_AGRESSION
        % generator for taxiTol1
        f_taxiTol1 = @(s,si,drop)aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,drop),1);
        mktd_taxiTol1 = @(drop) deal( struct ( ...
            "name"     , strcat("ATaxiTol1Drop", num2str(drop)), ...
            "testFunc" , @(s,si) f_taxiTol1(s,si,drop), ...
            "spectInfo", si_std ...
        ));

        % generator for taxiTol10
        f_taxiTol10 = @(s,si,drop)aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,drop),10);
        mktd_taxiTol10 = @(drop) deal( struct ( ...
            "name"     , strcat("ATaxiTol10Drop", num2str(drop)), ...
            "testFunc" , @(s,si) f_taxiTol10(s,si,drop), ...
            "spectInfo", si_std ...
        ));

        % generator for rectTol1
        f_rectTol1 = @(s,si,drop)aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_rectL2(s,si),100,drop),1);
        mktd_rectTol1 = @(drop) deal( struct ( ...
            "name"     , strcat("ARectTol1Drop", num2str(drop)), ...
            "testFunc" , @(s,si) f_rectTol1(s,si,drop), ...
            "spectInfo", si_std ...
        ));

        % generator for rectTol10
        f_rectTol10 = @(s,si,drop)aln_onsUtil_leadingEdge(block_normalise(aln_onsUtil_specDiff_rectL2(s,si),100,drop),10);
        mktd_rectTol10 = @(drop) deal( struct ( ...
            "name"     , strcat("ARectTol10Drop", num2str(drop)), ...
            "testFunc" , @(s,si) f_rectTol10(s,si,drop), ...
            "spectInfo", si_std ...
        ));

        % decide on db vals
        db_vals = [0, 3, 6, 9, 12, 15, 18];

        % generate testdefs
        % this is V MANY! dont use with everything else unless you have a lot of time
        for i  = 1:length(db_vals)
            testdefs{end+1} = mktd_taxiTol1(db_vals(i));
        end
        for i  = 1:length(db_vals)
            testdefs{end+1} = mktd_taxiTol10(db_vals(i));
        end
        for i  = 1:length(db_vals)
            testdefs{end+1} = mktd_rectTol1(db_vals(i));
        end
        for i  = 1:length(db_vals)
            testdefs{end+1} = mktd_rectTol10(db_vals(i));
        end
    end

    if TESTDEFS_NORMLEN
        % width 10
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),10,0);
        testdefs{end+1} = struct (...
            "name"     , "N10", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );
       
        % width 50
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),50,0);
        testdefs{end+1} = struct (...
            "name"     , "N50", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % width 100
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "N100", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % width 300
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),300,0);
        testdefs{end+1} = struct (...
            "name"     , "N300", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % width 1000
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),1000,0);
        testdefs{end+1} = struct (...
            "name"     , "N1000", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );
    end

    if TESTDEFS_SPECTINFO
        si_long_wlen = struct( ... 
            "wlen"    , 2048, ... 
            "nfft"    , 2048 * 4, ...
            "hop"     , 2048 / 4 ...
        );
        si_long_wlen.analwin = blackmanharris(si_long_wlen.wlen, 'periodic'); 
        si_long_wlen.synthwin = hamming(si_long_wlen.wlen, 'periodic');
        f = @(s,si)block_normalise(aln_onsUtil_specDiff_taxi(s,si),100,0);

        % standard spectInfo
        si = si_std;
        testdefs{end+1} = struct (...
            "name"     , "SStandard", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );

        % long Wlen long hop
        si = si_long_wlen;
        testdefs{end+1} = struct (...
            "name"     , "SLongWlenLongHop", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );

        % long Wlen, med hop
        si = si_long_wlen;
        si.hop = si.hop/2;
        testdefs{end+1} = struct (...
            "name"     , "SLongWlenMedHop", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );

        % long Wlen, short hop
        si = si_long_wlen;
        si.hop = si.hop/4;
        testdefs{end+1} = struct (...
            "name"     , "SLongWlenShortHop", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );
    end
end