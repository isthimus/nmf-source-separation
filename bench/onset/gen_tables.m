function [testvectors, testdefs] = gen_tables();
    % generates input tables for testbench.m
    TESTVECS_SOLO = true;
    TESTVECS_MIX = false;
    TESTDEFS_MAIN = true;
    TESTDEFS_NORMLEN = false;
    TESTDEFS_SPECTINFO = false;

    % make empty testvectors/testdefs
    testvectors = cell(0);
    testdefs = cell(0);

    % pick up some useful path strings
    PROJECT_PATH = fullfile('../../');
    TRIOS_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/TRIOS');
    PHENICX_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/PHENICX');
    DEV_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/development');

    % BUILD TEST VECTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if TESTVECS_SOLO
        % nice easy solo piano with lots of clear onsets
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartPiano", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/piano.wav"), ...
            "midiPath"  , fullfile(TRIOS_DATA_PATH, "mozart/piano.mid") ...
        );
        % viola with long notes - hard to avoid false positives
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartViola", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/viola.wav"), ...
            "midiPath"  , fullfile(TRIOS_DATA_PATH, "mozart/viola.mid") ...
        );
        % something low - cello
        testvectors{end+1} = struct( ...
            "name"       , "triosSchubertCello", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "schubert/cello.wav"), ...
            "midiPath"  , fullfile(TRIOS_DATA_PATH, "schubert/cello.mid") ...
        );
        % something high - flute
        testvectors{end+1} = struct( ...
            "name"       , "phenicxBrucknerFlute", ...
            "audioPath" , fullfile(PHENICX_DATA_PATH, "audio/bruckner/flute.wav"), ...
            "midiPath"  , fullfile(PHENICX_DATA_PATH, "annotations/bruckner/flute.mid") ... 
        );
    end

    if TESTVECS_MIX
        % mix - TRIOS brahms
        midi_stack( ...
            "./tmp/triosBrahmsMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "brahms/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "brahms/horn.mid"), ...
            fullfile(TRIOS_DATA_PATH, "brahms/violin.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosBrahmsMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "brahms/mix.wav"), ...
            "midiPath"  , "./tmp/triosBrahmsMix.mid" ...
        );
        
        % mix - TRIOS mozart
        midi_stack( ...
            "./tmp/triosMozartMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "mozart/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "mozart/clarinet.mid"), ...
            fullfile(TRIOS_DATA_PATH, "mozart/viola.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/mix.wav"), ...
            "midiPath"  , "./tmp/triosMozartMix.mid" ... 
        );

        % mix - TRIOS lussier
        midi_stack( ...
            "./tmp/triosLussierMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "lussier/bassoon.mid"), ...
            fullfile(TRIOS_DATA_PATH, "lussier/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "lussier/trumpet.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosLussierMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "lussier/mix.wav"), ...
            "midiPath"  , "./tmp/triosLussierMix.mid" ... 
        );

        % mix - TRIOS schubert
        midi_stack( ...
            "./tmp/triosSchubertMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "schubert/cello.mid"), ...
            fullfile(TRIOS_DATA_PATH, "schubert/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "schubert/violin.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosSchubertMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "schubert/mix.wav"), ...
            "midiPath"  , "./tmp/triosSchubertMix.mid" ... 
        );

        % mix - TRIOS take five
        midi_stack( ...
            "./tmp/triosTakeFiveMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "take_five/kick.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/ride.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/saxophone.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/snare.mid") ... 
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosTakeFiveMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "take_five/mix.wav"), ...
            "midiPath"  , "./tmp/triosTakeFiveMix.mid" ... 
        );

        % !!! NB not using PHENICX at the moment as no "mix.wav" is provided. not to 
        % hard to hack together midi files but audio is a different matter
        % (gain settings, etc).
        % maybe will come back to it.
    end
    
    % BUILD TESTDEFS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#

    % standard spectInfo
    si_std = struct( ... 
        "wlen"    , 1024, ... 
        "nfft"    , 1024 * 4, ...
        "hop"     , 1024 / 4 ...
    );
    si_std.analwin = blackmanharris(si_std.wlen, 'periodic'); 
    si_std.synthwin = hamming(si_std.wlen, 'periodic');

    if TESTDEFS_MAIN
        % standard taxicab
        testdefs{end+1} = struct (...
            "name"     , "MStandardTaxi", ...
            "testFunc" , @align_onset_specDiff_taxi, ...
            "spectInfo", si_std ...
        );

        % standard rectL2
        testdefs{end+1} = struct (...
            "name"     , "MStandardRectL2", ...
            "testFunc" , @align_onset_specDiff_rectL2, ...
            "spectInfo", si_std ...
        );

        % taxi with pesky zero
        testdefs{end+1} = struct (...
            "name"     , "MtaxiPesky0", ...
            "testFunc" , @align_onset_specDiff_taxi_pesky0, ...
            "spectInfo", si_std ...
        );

        % taxi, with block normalisation, width 100, no dropout thresh
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,-99);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiNormNoDroput", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % taxi, with block normalisation, width 100, dropout thresh at 0dB (ie drops out below mean)
        % this is an "agressive" onset detecting strategy
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiNormLowDropout", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % taxi, with block normalisation, width 100, dropout thresh at +10dB 
        % this is a "conservative" onset detecting strategy
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,7);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiNormHighDropout", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % agressive taxi (see above) with leading-edge detection, tol 1
        f = @(s,si)align_onset_leadingEdge(block_normalise(align_onset_specDiff_taxi(s,si),100,0),1);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiAgressLeadingEdge1", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % agressive taxi (see above) with leading-edge detection, tol 10
        f = @(s,si)align_onset_leadingEdge(block_normalise(align_onset_specDiff_taxi(s,si),100,0),10);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiAgressLeadingEdge10", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % conservative taxi (see above) with leading-edge detection, tol 1
        f = @(s,si)align_onset_leadingEdge(block_normalise(align_onset_specDiff_taxi(s,si),100,7),1);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiConservLeadingEdge1", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % conservative taxi (see above) with leading-edge detection, tol 10
        f = @(s,si)align_onset_leadingEdge(block_normalise(align_onset_specDiff_taxi(s,si),100,7),10);
        testdefs{end+1} = struct (...
            "name"     , "MTaxiConservLeadingEdge10", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );
    end

    if TESTDEFS_NORMLEN
        % width 10
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),10,0);
        testdefs{end+1} = struct (...
            "name"     , "N10", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );
       
        % width 50
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),50,0);
        testdefs{end+1} = struct (...
            "name"     , "N50", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % width 100
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "N100", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % width 300
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),300,0);
        testdefs{end+1} = struct (...
            "name"     , "N300", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );

        % width 1000
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),1000,0);
        testdefs{end+1} = struct (...
            "name"     , "N1000", ...
            "testFunc" , f, ...
            "spectInfo", si_std ...
        );
    end

    if TESTDEFS_SPECTINFO
        si_long_wlen = struct( ... 
            "wlen"    , 2048, ... 
            "nfft"    , 2048 * 4, ...
            "hop"     , 2048 / 4 ...
        );
        si_long_wlen.analwin = blackmanharris(si_long_wlen.wlen, 'periodic'); 
        si_long_wlen.synthwin = hamming(si_long_wlen.wlen, 'periodic');

        % standard spectInfo
        si = si_std;
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "SStandard", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );

        % long Wlen long hop
        si = si_long_wlen;
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "SLongWlenLongHop", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );

        % long Wlen, med hop
        si = si_long_wlen;
        si.hop = si.hop/2;
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "SLongWlenMedHop", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );

        % long Wlen, short hop
        si = si_long_wlen;
        si.hop = si.hop/4;
        f = @(s,si)block_normalise(align_onset_specDiff_taxi(s,si),100,0);
        testdefs{end+1} = struct (...
            "name"     , "SLongWlenShortHop", ...
            "testFunc" , f, ...
            "spectInfo", si ...
        );
    end
end