function [testvectors, testdefs] = gen_tables(switches)
    % generates input tables for testbench.m

    if nargin >= 1
        % pull out switches

        % testvector types
        TESTVECS_TRIOS = switches.TESTVECS_TRIOS;
        TESTVECS_TAKEFIVE = switches.TESTVECS_TAKEFIVE;
        
        % testdef types
        % hand aligned source sep - ie using midi masking with prealigned MIDI
        TESTDEFS_HASS = switches.TESTDEFS_HASS ;
        % Hand aligned masking. just mask with no NMF 
        TESTDEFS_HAM = switches.TESTDEFS_HAM;
        % score aligned source separaion - full pipeline
        TESTDEFS_SASS = switches.TESTDEFS_SASS;
    else 
        % when in doubt define everything
        TESTVECS_TRIOS = true;
        TESTVECS_TAKEFIVE = true;

        TESTDEFS_HASS = true;
        TESTDEFS_HAM = true;
        TESTDEFS_SASS = true;
    end

    % make empty testvectors/testdefs
    % a testdef is the algorithm/parameters used to solve the problem in a particular way
    % a testvec is a particular case of the problem
    testvectors = cell(0);
    testdefs = cell(0);

    % pick up some useful path strings
    PROJECT_PATH = fullfile('../../');
    TRIOS_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/TRIOS');
    PHENICX_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/PHENICX');
    DEV_DATA_PATH = fullfile(PROJECT_PATH, '/datasets/development');
    USER_FUNCS_PATH = fullfile(PROJECT_PATH, '/source/user');

    % define the tuned_funcs - ie the "best in class" for each numeric stage
    run(fullfile(USER_FUNCS_PATH, "gen_tuned_funcs"));

% BUILD TEST VECTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if TESTVECS_TRIOS

        % mix - TRIOS brahms
        sources = [
            string(fullfile(TRIOS_DATA_PATH, "brahms/piano.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "brahms/horn.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "brahms/violin.wav")) ...            
        ];
        midi_stack( ...
            "./tmp/triosBrahmsMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "brahms/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "brahms/horn.mid"), ...
            fullfile(TRIOS_DATA_PATH, "brahms/violin.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosBrahmsMix", ...
            "audioPath"  , fullfile(TRIOS_DATA_PATH, "brahms/mix.wav"), ...
            "midiPath"   , "./tmp/triosBrahmsMix.mid", ...
            "sourcePaths", sources ...
        );

        % mix - TRIOS mozart
        sources = [
            string(fullfile(TRIOS_DATA_PATH, "mozart/piano.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "mozart/clarinet.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "mozart/viola.wav")) ...
        ];
        midi_stack( ...
            "./tmp/triosMozartMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "mozart/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "mozart/clarinet.mid"), ...
            fullfile(TRIOS_DATA_PATH, "mozart/viola.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosMozartMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "mozart/mix.wav"), ...
            "midiPath"  , "./tmp/triosMozartMix.mid", ... 
            "sourcePaths", sources ...
        );

        % mix - TRIOS lussier
        sources = [
            string(fullfile(TRIOS_DATA_PATH, "lussier/bassoon.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "lussier/piano.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "lussier/trumpet.wav")) ...
        ];     
        midi_stack( ...
            "./tmp/triosLussierMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "lussier/bassoon.mid"), ...
            fullfile(TRIOS_DATA_PATH, "lussier/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "lussier/trumpet.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosLussierMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "lussier/mix.wav"), ...
            "midiPath"  , "./tmp/triosLussierMix.mid", ... 
            "sourcePaths", sources ...
        );

        % mix - TRIOS schubert
        sources = [
            string(fullfile(TRIOS_DATA_PATH, "schubert/cello.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "schubert/piano.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "schubert/violin.wav")) ...
        ];
        midi_stack( ...
            "./tmp/triosSchubertMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "schubert/cello.mid"), ...
            fullfile(TRIOS_DATA_PATH, "schubert/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "schubert/violin.mid") ...
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosSchubertMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "schubert/mix.wav"), ...
            "midiPath"  , "./tmp/triosSchubertMix.mid", ... 
            "sourcePaths", sources ...
        );
    end

    if TESTVECS_TAKEFIVE
        % mix - TRIOS take five
        sources = [
            string(fullfile(TRIOS_DATA_PATH, "take_five/kick.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "take_five/piano.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "take_five/ride.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "take_five/saxophone.wav")), ...
            string(fullfile(TRIOS_DATA_PATH, "take_five/snare.wav")) ... 
        ];
        midi_stack( ...
            "./tmp/triosTakeFiveMix.mid", ...
            fullfile(TRIOS_DATA_PATH, "take_five/kick.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/piano.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/ride.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/saxophone.mid"), ...
            fullfile(TRIOS_DATA_PATH, "take_five/snare.mid") ... 
        );
        testvectors{end+1} = struct( ...
            "name"       , "triosTakeFiveMix", ...
            "audioPath" , fullfile(TRIOS_DATA_PATH, "take_five/mix.wav"), ...
            "midiPath"  , "./tmp/triosTakeFiveMix.mid", ... 
            "sourcePaths", sources ...
        );
    end

% BUILD TEST DEFINITIONS

    if TESTDEFS_SASS
        % the parameters of the test series
        nmf_funcs = {@nss_nmf_euclidian, @nss_nmf_is, @nss_nmf_kl};
        align_funcs = {@align_tuned, @alignOnset_tuned};
        wlens = {1024, 2048, 4096, 8192};
        tol_funcs = {
            @(Wm,Hm,si) [Wm,Hm] % just return masks as is with no tol
            @(Wm,Hm,si) aln_tol_lin(Wm, 0, Hm, 10) % 10 bins of timeTol
        };

        % corresponding strings to name the generated testdefs with
        nmf_names = {"Euclid", "IS", "KL"};
        align_names = {"Dtw", "DtwOnset"};
        wlen_names = {"1024", "2048", "4096", "8192"};
        tol_names = {"NoTol", "10Tol"};

        % loop over every coombination of the above + build test
        for nmf_i = 1:length(nmf_funcs)
        for align_i = 1:length(align_funcs)
        for wlen_i = 1:length(wlens)
        for tol_i = 1:length(tol_funcs)
            
            % extract the current test params
            nmf_func = nmf_funcs{nmf_i};
            align_func = align_funcs{align_i};
            wlen = wlens{wlen_i};
            tol_func = tol_funcs{tol_i};

            % build spectInfo
            % NB all tests hardcoded to hop=256 for now
            %    see logbook, or final report draft for details
            % NB max_freq_bins chosen by observation of dataset spectra
            si = struct( ... 
                "wlen"         , wlen, ... 
                "nfft"         , wlen * 4, ...
                "hop"          , 256, ... 
                "analwin"      , blackmanharris(wlen, 'periodic'), ...
                "synthwin"     , hamming(wlen, 'periodic'), ...
                "max_freq_bins", floor(400 * wlen/1024) ...
            );

            % name the testDef
            tdName = sprintf ( ...
                "SASS-%s-%s-%s-%s", ...
                nmf_names{nmf_i}, ...
                align_names{align_i}, ...
                wlen_names{wlen_i}, ...
                tol_names{tol_i} ...
            );

            % create and add to the list of testdefs
            testdefs {end+1} = struct ( ...
                "name"       , tdName, ...
                "warpMidi"   , true, ...
                "spectInfo"  , si, ...
                "spect_func" , @nss_stft , ...
                "align_func" , align_func , ...
                "tol_func"   , tol_func, ...
                "nmf_func"   , nmf_func, ...
                "recons_func", @recons_tuned ... 
            );            
        end; end; end; end;
    end
    
    if TESTDEFS_HAM    
        wlens = {1024, 2048, 4096, 8192};

        for i = 1:length(wlens)
            % extract the current test params
            wlen = wlens{i};

            % dummy functions - just leave notes array unaltered, don't add any tolerance,
            % and don't perform NMF
            align_func_dummy = @(n,a,s,si) n;
            tol_func_dummy = @(Wm,Hm,si) [Wm,Hm];
            nmf_func_dummy = @(v,w,h) [w,h];

            % build spectInfo
            % NB all tests hardcoded to hop=256 for now
            %    see logbook, or final report draft for details
            % NB max_freq_bins chosen by observation of dataset spectra
            si = struct( ... 
                "wlen"         , wlen, ... 
                "nfft"         , wlen * 4, ...
                "hop"          , 256, ... 
                "analwin"      , blackmanharris(wlen, 'periodic'), ...
                "synthwin"     , hamming(wlen, 'periodic'), ...
                "max_freq_bins", floor(400 * wlen/1024) ...
            );

            % name the testDef
            tdName = sprintf ( ...
                "HAM.%d", ...
                wlen ... 
            );

            % create and add to the list of testdefs
            testdefs {end+1} = struct ( ... 
                "name"       , tdName, ...
                "warpMidi"   , true, ...
                "spectInfo"  , si, ...
                "spect_func" , @nss_stft , ...
                "align_func" , align_func_dummy , ...
                "tol_func"   , tol_func_dummy, ...
                "nmf_func"   , nmf_func_dummy, ...
                "recons_func", @recons_tuned ...
            );            
        end;
    end

    if TESTDEFS_HASS
        % the parameters of the test series
        nmf_funcs = {@nss_nmf_euclidian, @nss_nmf_is, @nss_nmf_kl};
        wlens = {1024, 2048, 4096, 8192};
        tol_funcs = {
            @(Wm,Hm,si) [Wm,Hm] % just return masks as is with no tol
            @(Wm,Hm,si) aln_tol_lin(Wm, 0, Hm, 10) % 10 bins of timeTol
        };

        % corresponding strings to name the generated testdefs with
        nmf_names = {"Euclid", "IS", "KL"};
        wlen_names = {"1024", "2048", "4096", "8192"};
        tol_names = {"NoTol", "10Tol"};

        % loop over every coombination of the above + build test
        for nmf_i = 1:length(nmf_funcs)
        for wlen_i = 1:length(wlens)
        for tol_i = 1:length(tol_funcs)
            
            % extract the current test params
            nmf_func = nmf_funcs{nmf_i};
            wlen = wlens{wlen_i};
            tol_func = tol_funcs{tol_i};

            % dummy alignment func which just returns notes unaltered
            align_func_dummy = @(n,a,s,si) n;

            % build spectInfo
            % NB all tests hardcoded to hop=256 for now
            %    see logbook, or final report draft for details
            % NB max_freq_bins chosen by observation of dataset spectra
            si = struct( ... 
                "wlen"         , wlen, ... 
                "nfft"         , wlen * 4, ...
                "hop"          , 256, ... 
                "analwin"      , blackmanharris(wlen, 'periodic'), ...
                "synthwin"     , hamming(wlen, 'periodic'), ...
                "max_freq_bins", floor(400 * wlen/1024) ...
            );

            % name the testDef
            tdName = sprintf ( ...
                "HASS-%s-%s-%s", ...
                nmf_names{nmf_i}, ...
                wlen_names{wlen_i}, ...
                tol_names{tol_i} ... 
            );

            % create and add to the list of testdefs
            testdefs {end+1} = struct ( ...
                "name"       , tdName, ...
                "warpMidi"   , false, ...
                "spectInfo"  , si, ...
                "spect_func" , @nss_stft , ...
                "align_func" , align_func_dummy , ...
                "tol_func"   , tol_func, ...
                "nmf_func"   , nmf_func, ...
                "recons_func", @recons_tuned ... 
            );            
        end; end; end;
    end  

end